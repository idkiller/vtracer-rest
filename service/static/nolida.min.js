/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ src)
});

;// CONCATENATED MODULE: external "Matter"
const external_Matter_namespaceObject = window["Matter"];
var external_Matter_default = /*#__PURE__*/__webpack_require__.n(external_Matter_namespaceObject);
;// CONCATENATED MODULE: ./src/index.js


function getLargestVerticesFromPath(path) {
  if (!path || path.constructor.name !== 'SVGPathElement') {
    throw Error('path is must SVGPathElement');
  }

  let verticeSet = pathToVerticeSet(path, true);
  let maxArea = external_Matter_default().Vertices.area(verticeSet[0]);
  let vertices = verticeSet[0];

  for (let i = 1; i < verticeSet.length; i++) {
    const area = external_Matter_default().Vertices.area(verticeSet[i]);

    if (maxArea < area) {
      maxArea = area;
      vertices = verticeSet[i];
    }
  }

  return vertices;
}

function createFromPath(path) {
  const vertices = getLargestVerticesFromPath(path);
  const svg = path.ownerSVGElement;
  const svgBox = svg.getBBox();
  const svgRect = svg.getBoundingClientRect();
  const ratio = {
    x: svgBox.width / svgRect.width,
    y: svgBox.height / svgRect.height
  };
  const rect = path.getBoundingClientRect();
  const x = rect.x * ratio.x;
  const y = rect.y * ratio.y;
  return createComposite(x, y, vertices, {
    isStatic: true,
    render: {
      opacity: 0
    }
  });
}

function createComposite(x, y, vertices, options) {
  const center = external_Matter_default().Vertices.centre(vertices);
  const body = {
    position: {
      x: x + center.x,
      y: y + center.y
    },
    vertices
  };
  return external_Matter_default().Body.create(external_Matter_default().Common.extend(body, options));
}

function pathToVerticeSet(path, zeroShift) {
  if (!path || path.constructor.name !== 'SVGPathElement') return;
  return pathStringToVerticeSet(path.getAttribute('d'), zeroShift);
}

function pathStringToVerticeSet(pathStr, zeroShift) {
  let verticeSet = [];
  let vertices = [];
  let numbers = [];
  let number = '';
  let c = null;
  let minX = 9999;
  let minY = 9999;
  let it = pathStr[Symbol.iterator]();

  while (true) {
    const n = it.next();
    if (n.done) break;
    c = n.value;

    switch (c) {
      case 'M':
        vertices = [];
        break;

      case 'L':
        const vertice = {
          x: numbers[0],
          y: numbers[1]
        };
        vertices.push(vertice);

        if (zeroShift) {
          minX = Math.min(vertice.x, minX);
          minY = Math.min(vertice.y, minY);
        }

        numbers = [];
        break;

      case 'Z':
        if (vertices && vertices.length > 0) {
          verticeSet.push(vertices);
        }

        break;

      case ',':
      case ' ':
        const n = parseFloat(number);

        if (!Number.isNaN(n)) {
          numbers.push(n);
        }

        number = '';
        break;

      case '-':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.':
        number += c;
        break;
    }
  }

  if (zeroShift) {
    minX = minX < 0 ? -minX : 0;
    minY = minY < 0 ? -minY : 0;

    for (let i = 0; i < verticeSet.length; i++) {
      for (let j = 0; j < verticeSet[i].length; j++) {
        verticeSet[i][j].x += minX;
        verticeSet[i][j].y += minY;
      }
    }
  }

  return verticeSet;
}

var loops = new Map();
var loopsIndex = 0;

function runSpec(ts, spec) {
  const generators = spec.generators;
  const mortals = spec.mortals;
  let i = generators.length;

  while (i--) {
    if (ts - generators[i].last > generators[i].time) {
      const generator = generators[i].generator;
      generators.splice(i, 1);
      generator(ts);
    }
  }

  i = mortals.length;

  while (i--) {
    const mortal = mortals[i];
    const bindings = mortal.bindings;

    if (bindings) {
      bindings.forEach(b => {
        if (b.cb(ts)) {
          mortals.splice(i, 1);
        }
      });
    }
  }
}

function OnContents(event) {
  const ts = event.timestamp;
  loops.forEach((value, key, map) => runSpec(ts, value));
}

function removePhysicsGlobalContents(index) {
  loops.delete(index);
} // eslint-disable-next-line


function makePhysicsGlobalContents(engine, width, height, spec) {
  const contents = spec.contents;
  const animation = contents.animation;
  const index = ++loopsIndex;
  const loop = {
    generators: [],
    mortals: []
  };
  loops.set(index, loop);

  function generator(last) {
    const x = SpecRange(contents.x) * width;
    const y = SpecRange(contents.y) * height;
    const body = SpecType(contents.type, x, y, contents.options);
    external_Matter_default().Composite.add(engine.world, body);
    body.name = `foobar${Math.floor(Math.random() * 1000)}`;

    if (animation) {
      loop.generators.push({
        time: SpecRange(animation.time),
        last,
        generator
      });
    }

    if (animation.bindings) {
      let cbs = [];

      for (let i = 0; i < animation.bindings.length; i++) {
        cbs.push(bindingToCb(engine, animation.bindings[i], body));
      }

      loop.mortals.push({
        body,
        bindings: cbs
      });
    }
  }

  generator(0);
  return index;
}

function bindingToCb(engine, binding, body) {
  binding.delay = binding.delay || 0;
  const obj = {
    last: engine.timing.timestamp + binding.delay,
    cb: null,
    body,
    binding
  };

  if (binding.name === 'dead') {
    obj.cb = function (t) {
      if (t - this.last >= 0) {
        external_Matter_default().Composite.remove(engine.world, this.body);
        return true;
      }
    };
  } else {
    makeBindableProperty(body, binding.name, obj);
    obj.easing = Easings[binding.easing];

    obj.cb = function (t) {
      if (t - this.last < 0) return false;
      const value = Math.max(0, Math.min(this.easing((t - this.last) / this.binding.duration), 1)) * (this.binding.value.to - this.binding.value.from) + this.binding.value.from;
      this.bindableProperty = value;
      return value === this.binding.value.to;
    };
  }

  return obj;
}

function makeBindableProperty(obj, path, binding) {
  const parts = path.split('.');

  for (let i = 0; i < parts.length - 1; i++) {
    if (!(parts[i] in obj)) throw new Error(`${parts[i]} is not in object`);
    obj = obj[parts[i]];
  }

  const key = parts[parts.length - 1];
  Object.defineProperty(binding, 'bindableProperty', {
    get: function () {
      return obj[key];
    },
    set: function (val) {
      obj[key] = val;
    }
  });
} // Number
// eslint-disable-next-line


function SpecBindableProperty(format) {} // Number | Array | {min: Number, max: Number}
// eslint-disable-next-line


function SpecRepeater(time) {
  if (typeof time === 'number') {
    return function (generator) {
      setTimeout(generator, time);
    };
  } else if (Array.isArray(time)) {
    return function (generator) {
      setTimeout(generator, time[Math.floor(Math.random() * time.length)]);
    };
  } else if (typeof time === 'object' && time !== null) {
    const min = time.min;
    const max = time.max;
    return function (generator) {
      setTimeout(generator, Math.random() * (max - min) + min);
    };
  } else {
    return null;
  }
}

function SpecType(type, x, y, options) {
  switch (type) {
    case 'circle':
      return external_Matter_default().Bodies.circle(x, y, SpecRange(options.radius), options);

    case 'vertices':
      return external_Matter_default().Bodies.fromVertices(x, y, options.vertices, options);

    case 'polygon':
      return external_Matter_default().Bodies.polygon(x, y, SpecRange(options.sides), SpecRange(options.radius), options);

    case 'rectangle':
      return external_Matter_default().Bodies.rectangle(x, y, SpecRange(options.width), SpecRange(options.height), options);

    case 'trapezoid':
      return external_Matter_default().Bodies.trapezoid(x, y, SpecRange(options.width), SpecRange(options.height), SpecRange(options.slope), options);
  }
} // Number | Array | {min: Number, max: Number}


function SpecRange(format) {
  if (typeof format === 'number') {
    return format;
  } else if (Array.isArray(format)) {
    return format[Math.floor(Math.random() * format.length)];
  } else if (typeof format === 'object' && format !== null) {
    const min = format.min;
    const max = format.max;
    return Math.random() * (max - min) + min;
  }

  throw new Error('it is wrong number format');
} // eslint-disable-next-line


function SpecRangeCB(format) {
  if (typeof format === 'number') {
    return () => format;
  } else if (Array.isArray(format)) {
    return () => format[Math.floor(Math.random() * format.length)];
  } else if (typeof format === 'object' && format !== null) {
    const min = format.min;
    const max = format.max;
    return () => Math.random() * (max - min) + min;
  }

  throw new Error('it is wrong number format');
}

const easeIn = p => t => Math.pow(t, p);

const easeOut = p => t => 1 - easeIn(p)(1 - t);

const easeInOut = p => t => t < 0.5 ? easeIn(p)(t * 2) / 2 : easeOut(p)(t * 2 - 1) / 2 + 0.5;

const Easings = {
  linear: easeIn(1),
  easeInQuad: easeIn(2),
  easeOutQuad: easeOut(2),
  easeInOutQuad: easeInOut(2),
  easeInCubic: easeIn(3),
  easeOutCubic: easeOut(3),
  easeInOutCubic: easeInOut(3),
  easeInQuart: easeIn(4),
  easeOutQuart: easeOut(4),
  easeInOutQuart: easeInOut(4),
  easeInQuint: easeIn(5),
  easeOutQuint: easeOut(5),
  easeInOutQuint: easeInOut(5)
};
/* harmony default export */ const src = ({
  OnContents,
  makePhysicsGlobalContents,
  removePhysicsGlobalContents,
  createFromPath,
  createComposite,
  getLargestVerticesFromPath
});
window.nolida = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=nolida.min.js.map